package deployments

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/krzachariassen/ZTDP/internal/agentFramework"
	"github.com/krzachariassen/ZTDP/internal/agentRegistry"
	"github.com/krzachariassen/ZTDP/internal/ai"
	"github.com/krzachariassen/ZTDP/internal/events"
	"github.com/krzachariassen/ZTDP/internal/graph"
	"github.com/krzachariassen/ZTDP/internal/logging"
)

// FrameworkDeploymentAgent wraps the deployment business logic in the new agent framework
type FrameworkDeploymentAgent struct {
	service      *Service
	env          string
	logger       *logging.Logger
	currentEvent *events.Event // Store current event context for correlation
}

// NewDeploymentAgent creates a DeploymentAgent using the agent framework
func NewDeploymentAgent(
	graph *graph.GlobalGraph,
	aiProvider ai.AIProvider,
	env string,
	eventBus *events.EventBus,
	registry agentRegistry.AgentRegistry,
) (agentRegistry.AgentInterface, error) {
	// Create the deployment service for business logic
	service := NewDeploymentService(graph, aiProvider)

	// Create the wrapper that contains the business logic
	wrapper := &FrameworkDeploymentAgent{
		service: service,
		env:     env,
		logger:  logging.GetLogger().ForComponent("deployment-agent"),
	}

	// Create dependencies for the framework
	deps := agentFramework.AgentDependencies{
		Registry: registry,
		EventBus: eventBus,
	}

	// Build the agent using the framework
	agent, err := agentFramework.NewAgent("deployment-agent").
		WithType("deployment").
		WithCapabilities(getDeploymentCapabilities()).
		WithEventHandler(wrapper.handleEvent).
		Build(deps)

	if err != nil {
		return nil, fmt.Errorf("failed to build framework deployment agent: %w", err)
	}

	wrapper.logger.Info("âœ… FrameworkDeploymentAgent created successfully")
	return agent, nil
}

// getDeploymentCapabilities returns the capabilities for the deployment agent
func getDeploymentCapabilities() []agentRegistry.AgentCapability {
	return []agentRegistry.AgentCapability{
		{
			Name:        "deployment_orchestration",
			Description: "AI-native deployment orchestration with intelligent planning and execution",
			Intents:     []string{"deploy application", "execute deployment", "start deployment", "run deployment"},
			InputTypes:  []string{"application_name", "environment", "deployment_plan"},
			OutputTypes: []string{"deployment_result", "deployment_status", "error_details"},
			RoutingKeys: []string{"deployment.request", "deployment.execute", "deployment.orchestrate"},
			Version:     "1.0.0",
		},
		{
			Name:        "deployment_planning",
			Description: "Creates AI-enhanced deployment plans with optimization and risk analysis",
			Intents:     []string{"plan deployment", "create deployment plan", "generate deployment strategy"},
			InputTypes:  []string{"application_name", "environment", "constraints"},
			OutputTypes: []string{"deployment_plan", "optimization_recommendations", "risk_analysis"},
			RoutingKeys: []string{"deployment.plan", "deployment.strategy"},
			Version:     "1.0.0",
		},
		{
			Name:        "deployment_status_updates",
			Description: "Receives status updates and notifications from other agents",
			Intents:     []string{"deployment status update", "release status", "deployment notification"},
			InputTypes:  []string{"status_update", "correlation_id", "release_status"},
			OutputTypes: []string{"acknowledgment", "status_confirmation"},
			RoutingKeys: []string{"deployment.status", "deployment.update", "deployment.notification"},
			Version:     "1.0.0",
		},
	}
}

// handleEvent is the main event handler that preserves the existing business logic
func (a *FrameworkDeploymentAgent) handleEvent(ctx context.Context, event *events.Event) (*events.Event, error) {
	// Store current event for correlation context
	a.currentEvent = event

	a.logger.Info("ðŸŽ¯ Processing event: %s", event.Subject)

	// Extract intent from event payload using framework pattern
	intent, ok := event.Payload["intent"].(string)
	if !ok || intent == "" {
		return a.createErrorResponse(event, "intent field required in payload"), nil
	}

	// Route based on intent - using a cleaner pattern
	intentHandlers := map[string]func(context.Context, *events.Event) (*events.Event, error){
		"deploy": a.handleDeployApplication,
		"plan":   a.handleCreateDeploymentPlan,
		"status": a.handleGetDeploymentStatus,
	}

	// Try exact match first
	if handler, exists := intentHandlers[intent]; exists {
		return handler(ctx, event)
	}

	// Try pattern matching with strings.Contains
	for pattern, handler := range intentHandlers {
		if strings.Contains(intent, pattern) {
			return handler(ctx, event)
		}
	}

	// Default to generic handler
	return a.handleGenericQuestion(ctx, event, intent)
}

// handleDeployApplication processes application deployment requests using AI-native parsing
func (a *FrameworkDeploymentAgent) handleDeployApplication(ctx context.Context, event *events.Event) (*events.Event, error) {
	a.logger.Info("ðŸ” Payload keys: %v", agentFramework.GetPayloadKeys(event.Payload))

	// Extract user message using framework pattern
	var userMessage string
	var found bool

	// Check top-level payload first
	if msg, ok := event.Payload["user_message"].(string); ok && msg != "" {
		userMessage = msg
		found = true
		a.logger.Info("ðŸ” Found user_message at top level: %s", userMessage)
	} else if contextData, ok := event.Payload["context"].(map[string]interface{}); ok {
		a.logger.Info("ðŸ” Context keys: %v", agentFramework.GetPayloadKeys(contextData))
		if msg, ok := contextData["user_message"].(string); ok && msg != "" {
			userMessage = msg
			found = true
			a.logger.Info("ðŸ” Found user_message in context: %s", userMessage)
		}
	}

	if !found {
		return a.createErrorResponse(event, "user_message required for AI-native deployment processing"), nil
	}

	a.logger.Info("ðŸ¤– AI-parsing deployment request: %s", userMessage)

	// Step 1: Use AI to extract application and environment from natural language
	appName, environment, err := a.parseDeploymentRequest(ctx, userMessage)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("failed to parse deployment request: %v", err)), nil
	}

	a.logger.Info("ðŸŽ¯ Resolved deployment: %s -> %s", appName, environment)

	// Step 2: Validate application and environment existence using framework pattern
	if err := a.validateNodeExists("application", appName); err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("application validation failed: %v", err)), nil
	}

	if err := a.validateNodeExists("environment", environment); err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("environment validation failed: %v", err)), nil
	}

	// Step 3: Execute deployment using the service layer
	result, err := a.service.DeployApplication(ctx, appName, environment)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("deployment failed: %v", err)), nil
	}

	return a.createSuccessResponse(event, map[string]interface{}{
		"status":            "success",
		"message":           fmt.Sprintf("Deployment of %s to %s completed successfully", appName, environment),
		"application":       appName,
		"environment":       environment,
		"deployment_result": result,
		"timestamp":         time.Now(),
	}), nil
}

// handleCreateDeploymentPlan creates an AI-enhanced deployment plan
func (a *FrameworkDeploymentAgent) handleCreateDeploymentPlan(ctx context.Context, event *events.Event) (*events.Event, error) {
	// Extract application name
	appName, ok := event.Payload["application"].(string)
	if !ok {
		// Try to extract from user message using AI
		if userMessage, exists := event.Payload["user_message"].(string); exists {
			var err error
			appName, _, err = a.parseDeploymentRequest(ctx, userMessage)
			if err != nil {
				return a.createErrorResponse(event, "failed to extract application from request"), nil
			}
		} else {
			return a.createErrorResponse(event, "application name required"), nil
		}
	}

	// Create deployment plan using service layer
	plan, err := a.service.GenerateDeploymentPlan(ctx, appName)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("failed to create deployment plan: %v", err)), nil
	}

	return a.createSuccessResponse(event, map[string]interface{}{
		"status":          "success",
		"application":     appName,
		"deployment_plan": plan,
		"timestamp":       time.Now(),
	}), nil
}

// handleGetDeploymentStatus retrieves deployment status
func (a *FrameworkDeploymentAgent) handleGetDeploymentStatus(ctx context.Context, event *events.Event) (*events.Event, error) {
	appName, ok := event.Payload["application"].(string)
	if !ok {
		return a.createErrorResponse(event, "application name required"), nil
	}

	// Get deployment status using service layer
	status, err := a.service.GetDeploymentStatus(appName, a.env)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("failed to get deployment status: %v", err)), nil
	}

	return a.createSuccessResponse(event, map[string]interface{}{
		"status":            "success",
		"application":       appName,
		"deployment_status": status,
		"timestamp":         time.Now(),
	}), nil
}

// handleGenericQuestion handles general deployment-related questions
func (a *FrameworkDeploymentAgent) handleGenericQuestion(ctx context.Context, event *events.Event, intent string) (*events.Event, error) {
	a.logger.Info("ðŸ¤” Handling generic deployment question: %s", intent)

	// For now, provide a simple response - can be enhanced with AI later
	response := fmt.Sprintf("I understand you're asking about: %s. I can help with deployment operations like 'deploy application to environment', 'create deployment plan', and 'get deployment status'.", intent)

	return a.createSuccessResponse(event, map[string]interface{}{
		"status":    "success",
		"response":  response,
		"intent":    intent,
		"timestamp": time.Now().Unix(),
	}), nil
}

// Helper methods preserved from original implementation

// parseDeploymentRequest uses AI to extract application and environment from natural language
func (a *FrameworkDeploymentAgent) parseDeploymentRequest(ctx context.Context, userMessage string) (string, string, error) {
	if a.service == nil || a.service.aiProvider == nil {
		// Fallback parsing - try to extract from simple patterns
		return a.parseDeploymentRequestFallback(userMessage)
	}

	// Use AI to parse the deployment request
	systemPrompt := `You are a deployment request parser. Extract the application name and environment from the user's message.
Return ONLY a JSON object with "application" and "environment" fields.
If environment is not specified, use "development" as default.

Examples:
Input: "deploy myapp to production"
Output: {"application": "myapp", "environment": "production"}

Input: "I want to deploy the user-service"
Output: {"application": "user-service", "environment": "development"}
`

	userPrompt := fmt.Sprintf("Parse this deployment request: %s", userMessage)

	response, err := a.service.aiProvider.CallAI(ctx, systemPrompt, userPrompt)
	if err != nil {
		a.logger.Warn("AI parsing failed, using fallback: %v", err)
		return a.parseDeploymentRequestFallback(userMessage)
	}

	// Parse the AI response
	var parsed struct {
		Application string `json:"application"`
		Environment string `json:"environment"`
	}

	if err := parseJSONResponse(response, &parsed); err != nil {
		a.logger.Warn("AI response parsing failed, using fallback: %v", err)
		return a.parseDeploymentRequestFallback(userMessage)
	}

	if parsed.Application == "" {
		return "", "", fmt.Errorf("could not extract application name from message")
	}

	if parsed.Environment == "" {
		parsed.Environment = "development"
	}

	return parsed.Application, parsed.Environment, nil
}

// parseDeploymentRequestFallback provides simple pattern-based parsing when AI is unavailable
func (a *FrameworkDeploymentAgent) parseDeploymentRequestFallback(userMessage string) (string, string, error) {
	// Simple pattern matching for common deployment patterns
	message := strings.ToLower(userMessage)

	// Try to extract application name
	words := strings.Fields(message)
	var appName, environment string = "", "development"

	for i, word := range words {
		if word == "deploy" && i+1 < len(words) {
			appName = words[i+1]
		}
		if word == "to" && i+1 < len(words) {
			environment = words[i+1]
		}
	}

	if appName == "" {
		return "", "", fmt.Errorf("could not extract application name from message")
	}

	return appName, environment, nil
}

// validateNodeExists validates that a node with specific kind and name exists using framework helper
func (a *FrameworkDeploymentAgent) validateNodeExists(kind, name string) error {
	return a.service.ValidateNodeExists(kind, name)
}

// validateApplicationExists validates that the application exists (DEPRECATED - use validateNodeExists)
func (a *FrameworkDeploymentAgent) validateApplicationExists(ctx context.Context, appName string) error {
	return a.validateNodeExists("application", appName)
}

// validateEnvironmentExists validates that the environment exists (DEPRECATED - use validateNodeExists)
func (a *FrameworkDeploymentAgent) validateEnvironmentExists(ctx context.Context, environment string) error {
	return a.validateNodeExists("environment", environment)
}

// createErrorResponse creates a standardized error response
func (a *FrameworkDeploymentAgent) createErrorResponse(originalEvent *events.Event, errorMsg string) *events.Event {
	payload := map[string]interface{}{
		"status":      "error",
		"error":       errorMsg,
		"original_id": originalEvent.ID,
		"timestamp":   time.Now().Unix(),
		"agent_id":    "deployment-agent",
	}

	// Preserve correlation_id if it exists
	if correlationID, ok := originalEvent.Payload["correlation_id"]; ok {
		payload["correlation_id"] = correlationID
	}

	return &events.Event{
		ID:        fmt.Sprintf("response-%s", originalEvent.ID),
		Type:      events.EventTypeResponse,
		Subject:   "deployment.response.error",
		Source:    "deployment-agent",
		Timestamp: time.Now().Unix(),
		Payload:   payload,
	}
}

// createSuccessResponse creates a standardized success response
func (a *FrameworkDeploymentAgent) createSuccessResponse(originalEvent *events.Event, payload map[string]interface{}) *events.Event {
	// Ensure required fields
	payload["original_id"] = originalEvent.ID
	payload["agent_id"] = "deployment-agent"

	// Preserve correlation_id if it exists
	if correlationID, ok := originalEvent.Payload["correlation_id"]; ok {
		payload["correlation_id"] = correlationID
	}

	return &events.Event{
		ID:        fmt.Sprintf("response-%s", originalEvent.ID),
		Type:      events.EventTypeResponse,
		Subject:   "deployment.response.success",
		Source:    "deployment-agent",
		Timestamp: time.Now().Unix(),
		Payload:   payload,
	}
}

// parseJSONResponse parses AI JSON responses with cleanup
func parseJSONResponse(response string, target interface{}) error {
	// Clean up the response - remove any markdown code blocks
	cleaned := strings.TrimSpace(response)
	cleaned = strings.TrimPrefix(cleaned, "```json")
	cleaned = strings.TrimPrefix(cleaned, "```")
	cleaned = strings.TrimSuffix(cleaned, "```")
	cleaned = strings.TrimSpace(cleaned)

	return json.Unmarshal([]byte(cleaned), target)
}
