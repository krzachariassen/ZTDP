package deployments

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/krzachariassen/ZTDP/internal/agents"
	"github.com/krzachariassen/ZTDP/internal/ai"
	"github.com/krzachariassen/ZTDP/internal/events"
	"github.com/krzachariassen/ZTDP/internal/graph"
	"github.com/krzachariassen/ZTDP/internal/logging"
)

// DeploymentAgent implements AgentInterface for intelligent deployment orchestration
// This agent handles complex deployment workflows, AI-enhanced planning, and failure analysis
type DeploymentAgent struct {
	service       *Service
	agentID       string
	env           string
	eventBus      *events.EventBus // Use actual EventBus instead of interface
	agentRegistry agents.AgentRegistry
	startTime     time.Time
	logger        *logging.Logger
}

// NewDeploymentAgent creates a new DeploymentAgent that auto-registers with the agent registry
func NewDeploymentAgent(graph *graph.GlobalGraph, aiProvider ai.AIProvider, env string, eventBus *events.EventBus, agentRegistry agents.AgentRegistry) (agents.AgentInterface, error) {
	service := NewDeploymentService(graph, aiProvider)
	agent := &DeploymentAgent{
		service:       service,
		agentID:       "deployment-agent",
		env:           env,
		eventBus:      eventBus,
		agentRegistry: agentRegistry,
		startTime:     time.Now(),
		logger:        logging.GetLogger().ForComponent("deployment-agent"),
	}

	// Auto-register with the agent registry
	if agentRegistry != nil {
		ctx := context.Background()
		if err := agentRegistry.RegisterAgent(ctx, agent); err != nil {
			agent.logger.Error("❌ Failed to auto-register deployment agent: %v", err)
			return nil, fmt.Errorf("failed to auto-register deployment agent: %w", err)
		}
		agent.logger.Info("✅ DeploymentAgent auto-registered successfully")
	} else {
		agent.logger.Warn("⚠️ No agent registry provided - agent will not be discoverable")
	}

	// Subscribe to specific routing keys so the agent only receives relevant events
	if eventBus != nil {
		// Subscribe to all routing keys this agent handles
		capabilities := agent.GetCapabilities()
		for _, capability := range capabilities {
			for _, routingKey := range capability.RoutingKeys {
				eventBus.SubscribeToRoutingKey(routingKey, agent.handleIncomingEvent)
				agent.logger.Info("✅ DeploymentAgent subscribed to routing key: %s", routingKey)
			}
		}
	} else {
		agent.logger.Warn("⚠️ No event bus provided - agent will not receive events")
	}

	return agent, nil
}

// GetID returns the agent's unique identifier
func (a *DeploymentAgent) GetID() string {
	return a.agentID
}

// GetStatus returns current agent status information
func (a *DeploymentAgent) GetStatus() agents.AgentStatus {
	return agents.AgentStatus{
		ID:           a.agentID,
		Type:         "deployment",
		Status:       "running",
		LastActivity: time.Now(),
		LoadFactor:   0.3, // Deployments can be resource intensive
		Version:      "1.0.0",
		Metadata: map[string]interface{}{
			"environment":     a.env,
			"ai_capabilities": a.service.HasAICapabilities(),
			"ai_provider":     a.getAIProviderName(),
			"operations":      []string{"deploy", "plan", "optimize", "troubleshoot", "predict", "rollback"},
		},
	}
}

// GetCapabilities returns the agent's capabilities
func (a *DeploymentAgent) GetCapabilities() []agents.AgentCapability {
	return []agents.AgentCapability{
		{
			Name:        "deployment_orchestration",
			Description: "Orchestrates complex deployment workflows with AI-enhanced decision making",
			Intents:     []string{"deploy application", "execute deployment", "orchestrate deployment"},
			InputTypes:  []string{"application_name", "environment", "deployment_plan"},
			OutputTypes: []string{"deployment_result", "deployment_status", "error_details"},
			RoutingKeys: []string{"deployment.request", "deployment.execute", "deployment.orchestrate"},
			Version:     "1.0.0",
		},
		{
			Name:        "deployment_planning",
			Description: "Creates AI-enhanced deployment plans with optimization and risk analysis",
			Intents:     []string{"plan deployment", "create deployment plan", "generate deployment strategy"},
			InputTypes:  []string{"application_name", "environment", "constraints"},
			OutputTypes: []string{"deployment_plan", "optimization_recommendations", "risk_analysis"},
			RoutingKeys: []string{"deployment.plan", "deployment.strategy"},
			Version:     "1.0.0",
		},
		{
			Name:        "deployment_optimization",
			Description: "Optimizes deployment plans using AI analysis for better performance and reliability",
			Intents:     []string{"optimize deployment", "improve deployment plan", "enhance deployment strategy"},
			InputTypes:  []string{"deployment_plan", "performance_metrics", "constraints"},
			OutputTypes: []string{"optimization_recommendations", "performance_improvements"},
			RoutingKeys: []string{"deployment.optimize", "deployment.enhance"},
			Version:     "1.0.0",
		},
		{
			Name:        "deployment_troubleshooting",
			Description: "AI-powered troubleshooting and failure analysis for deployment issues",
			Intents:     []string{"troubleshoot deployment", "analyze deployment failure", "diagnose deployment issues"},
			InputTypes:  []string{"incident_id", "error_description", "symptoms", "logs"},
			OutputTypes: []string{"troubleshooting_response", "root_cause_analysis", "resolution_steps"},
			RoutingKeys: []string{"deployment.troubleshoot", "deployment.diagnose"},
			Version:     "1.0.0",
		},
		{
			Name:        "impact_prediction",
			Description: "Predicts deployment impact and potential risks using AI analysis",
			Intents:     []string{"predict impact", "analyze deployment risks", "assess deployment effects"},
			InputTypes:  []string{"proposed_changes", "environment", "current_state"},
			OutputTypes: []string{"impact_prediction", "risk_assessment", "mitigation_strategies"},
			Version:     "1.0.0",
		},
		{
			Name:        "deployment_status_updates",
			Description: "Receives status updates and notifications from other agents (ReleaseAgent, etc.)",
			Intents:     []string{"deployment status update", "release status", "deployment notification"},
			InputTypes:  []string{"status_update", "correlation_id", "release_status"},
			OutputTypes: []string{"acknowledgment", "status_confirmation"},
			RoutingKeys: []string{"deployment.status", "deployment.update", "deployment.notification"},
			Version:     "1.0.0",
		},
	}
}

// Start initializes the agent
func (a *DeploymentAgent) Start(ctx context.Context) error {
	a.logger.Info("🤖 DeploymentAgent starting up")
	return nil
}

// Stop gracefully shuts down the agent
func (a *DeploymentAgent) Stop(ctx context.Context) error {
	a.logger.Info("🤖 DeploymentAgent shutting down")
	return nil
}

// Health returns the agent's health status
func (a *DeploymentAgent) Health() agents.HealthStatus {
	aiHealthy := a.service.HasAICapabilities()
	status := "healthy"
	if !aiHealthy {
		status = "degraded"
	}

	return agents.HealthStatus{
		Healthy: true, // Agent can work without AI, just degraded
		Status:  status,
		Message: "Deployment agent is operational",
		Checks: map[string]interface{}{
			"graph_connection":  "connected",
			"event_bus":         "connected",
			"ai_provider":       aiHealthy,
			"deployment_engine": "ready",
		},
		CheckedAt: time.Now(),
	}
}

// ProcessEvent handles incoming events for the deployment agent
func (a *DeploymentAgent) ProcessEvent(ctx context.Context, event *events.Event) (*events.Event, error) {
	// Validate event has required intent field
	intent, ok := event.Payload["intent"].(string)
	if !ok {
		return nil, fmt.Errorf("deployment agent requires 'intent' field in payload")
	}

	a.logger.Info("🤖 Processing deployment event with intent: %s", intent)

	// Route based on intent
	switch intent {
	case "deployment_orchestration", "deploy_application", "deploy application":
		return a.handleDeployApplication(ctx, event)
	case "deployment_planning", "create_deployment_plan":
		return a.handleCreateDeploymentPlan(ctx, event)
	case "deployment_optimization", "optimize_deployment_plan":
		return a.handleOptimizeDeploymentPlan(ctx, event)
	case "deployment_troubleshooting", "troubleshoot_deployment":
		return a.handleTroubleshootDeployment(ctx, event)
	case "impact_prediction", "predict_deployment_impact":
		return a.handlePredictDeploymentImpact(ctx, event)
	case "deployment_status", "get_deployment_status":
		return a.handleGetDeploymentStatus(ctx, event)
	default:
		return a.handleGenericQuestion(ctx, event, intent)
	}
}

// handleDeployApplication processes application deployment requests using AI-native parsing
func (a *DeploymentAgent) handleDeployApplication(ctx context.Context, event *events.Event) (*events.Event, error) {
	a.logger.Info("🔍 Payload keys: %v", getKeys(event.Payload))

	// AI-NATIVE APPROACH: Extract user message from context or top-level payload
	var userMessage string

	// Try to get user_message from top level first
	if msg, ok := event.Payload["user_message"].(string); ok {
		userMessage = msg
		a.logger.Info("🔍 Found user_message at top level: %s", userMessage)
	} else if contextData, ok := event.Payload["context"].(map[string]interface{}); ok {
		// Try to get user_message from nested context
		a.logger.Info("🔍 Context keys: %v", getKeys(contextData))
		if msg, ok := contextData["user_message"].(string); ok {
			userMessage = msg
			a.logger.Info("🔍 Found user_message in context: %s", userMessage)
		}
	}

	if userMessage == "" {
		return a.createErrorResponse(event, "user_message required for AI-native deployment processing"), nil
	}

	a.logger.Info("🤖 AI-parsing deployment request: %s", userMessage)

	// Step 1: Use AI to extract application and environment from natural language
	appName, environment, err := a.parseDeploymentRequest(ctx, userMessage)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("failed to parse deployment request: %v", err)), nil
	}

	a.logger.Info("🎯 Resolved deployment: %s -> %s", appName, environment)

	// Step 2: Build rich AI-native deployment plan with Release node
	deploymentPlan, err := a.buildDeploymentPlan(ctx, appName, environment)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("failed to build deployment plan: %v", err)), nil
	}

	// Step 3: Create conversational response explaining the deployment plan
	planExplanation, err := a.generateDeploymentPlanExplanation(ctx, deploymentPlan)
	if err != nil {
		planExplanation = "Basic deployment plan generated successfully"
	}

	// TODO: Consult PolicyAgent for deployment policies before executing
	// This will be added in a future iteration to ensure compliance

	// Step 4: Execute deployment using the service
	result, err := a.service.DeployApplication(ctx, appName, environment)
	if err != nil {
		// Rich error response with context
		errorMsg := fmt.Sprintf("%s\n\n❌ Deployment execution failed: %v", planExplanation, err)
		return a.createErrorResponse(event, errorMsg), nil
	}

	// Step 5: Emit success event
	if a.eventBus != nil {
		a.eventBus.Emit(events.EventTypeNotify, "deployment-agent", "deployment.completed", map[string]interface{}{
			"application_name":  appName,
			"environment":       environment,
			"status":            result.Status,
			"services_deployed": result.Summary.Deployed,
			"deployment_id":     result.DeploymentID,
			"release_id":        deploymentPlan["release_id"],
		})
	}

	// Step 6: Rich success response
	releaseID, _ := deploymentPlan["release_id"].(string)
	successMsg := fmt.Sprintf("%s\n\n✅ Deployment completed successfully! Release %s is now live in %s.",
		planExplanation, releaseID, environment)

	return a.createResponse(successMsg, map[string]interface{}{
		"status":            "success",
		"operation":         "deploy",
		"application_name":  appName,
		"environment":       environment,
		"deployment_result": result,
		"deployment_plan":   deploymentPlan,
	}, event), nil
}

// handleCreateDeploymentPlan processes deployment planning requests
func (a *DeploymentAgent) handleCreateDeploymentPlan(ctx context.Context, event *events.Event) (*events.Event, error) {
	appName, ok := event.Payload["application_name"].(string)
	if !ok {
		return a.createErrorResponse(event, "application_name required for deployment planning"), nil
	}

	a.logger.Info("📋 Creating deployment plan for %s", appName)

	plan, err := a.service.GenerateDeploymentPlan(ctx, appName)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("deployment planning failed: %v", err)), nil
	}

	return a.createResponse("Deployment plan created", map[string]interface{}{
		"status":           "success",
		"operation":        "plan",
		"application_name": appName,
		"deployment_plan":  plan,
	}, event), nil
}

// handleOptimizeDeploymentPlan processes deployment optimization requests
func (a *DeploymentAgent) handleOptimizeDeploymentPlan(ctx context.Context, event *events.Event) (*events.Event, error) {
	appID, ok := event.Payload["application_id"].(string)
	if !ok {
		return a.createErrorResponse(event, "application_id required for optimization"), nil
	}

	// Extract current plan from event payload
	planData, ok := event.Payload["current_plan"]
	if !ok {
		return a.createErrorResponse(event, "current_plan required for optimization"), nil
	}

	// Convert to deployment steps
	var currentPlan []ai.DeploymentStep
	if err := a.convertToDeploymentSteps(planData, &currentPlan); err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("invalid deployment plan format: %v", err)), nil
	}

	a.logger.Info("🔧 Optimizing deployment plan for %s", appID)

	recommendations, err := a.service.OptimizeDeploymentPlan(ctx, appID, currentPlan)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("deployment optimization failed: %v", err)), nil
	}

	return &events.Event{
		Type:    events.EventTypeResponse,
		Source:  a.agentID,
		Subject: "Deployment plan optimized",
		Payload: map[string]interface{}{
			"status":          "success",
			"operation":       "optimize",
			"application_id":  appID,
			"recommendations": recommendations,
		},
	}, nil
}

// handleTroubleshootDeployment processes deployment troubleshooting requests
func (a *DeploymentAgent) handleTroubleshootDeployment(ctx context.Context, event *events.Event) (*events.Event, error) {
	incidentID, ok := event.Payload["incident_id"].(string)
	if !ok {
		return a.createErrorResponse(event, "incident_id required for troubleshooting"), nil
	}

	description, ok := event.Payload["description"].(string)
	if !ok {
		return a.createErrorResponse(event, "description required for troubleshooting"), nil
	}

	symptoms, _ := event.Payload["symptoms"].([]string)
	if symptoms == nil {
		symptoms = []string{}
	}

	a.logger.Info("🔍 Troubleshooting deployment incident %s", incidentID)

	response, err := a.service.TroubleshootDeployment(ctx, incidentID, description, symptoms)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("deployment troubleshooting failed: %v", err)), nil
	}

	return &events.Event{
		Type:    events.EventTypeResponse,
		Source:  a.agentID,
		Subject: "Deployment troubleshooting completed",
		Payload: map[string]interface{}{
			"status":                   "success",
			"operation":                "troubleshoot",
			"incident_id":              incidentID,
			"troubleshooting_response": response,
		},
	}, nil
}

// handlePredictDeploymentImpact processes impact prediction requests
func (a *DeploymentAgent) handlePredictDeploymentImpact(ctx context.Context, event *events.Event) (*events.Event, error) {
	environment, ok := event.Payload["environment"].(string)
	if !ok {
		return a.createErrorResponse(event, "environment required for impact prediction"), nil
	}

	changesData, ok := event.Payload["proposed_changes"]
	if !ok {
		return a.createErrorResponse(event, "proposed_changes required for impact prediction"), nil
	}

	// Convert to proposed changes
	var changes []ai.ProposedChange
	if err := a.convertToProposedChanges(changesData, &changes); err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("invalid proposed changes format: %v", err)), nil
	}

	a.logger.Info("📊 Predicting deployment impact for %d changes in %s", len(changes), environment)

	prediction, err := a.service.PredictDeploymentImpact(ctx, changes, environment)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("impact prediction failed: %v", err)), nil
	}

	return &events.Event{
		Type:    events.EventTypeResponse,
		Source:  a.agentID,
		Subject: "Deployment impact predicted",
		Payload: map[string]interface{}{
			"status":            "success",
			"operation":         "predict_impact",
			"environment":       environment,
			"impact_prediction": prediction,
		},
	}, nil
}

// handleGetDeploymentStatus processes deployment status requests
func (a *DeploymentAgent) handleGetDeploymentStatus(ctx context.Context, event *events.Event) (*events.Event, error) {
	appName, ok := event.Payload["application_name"].(string)
	if !ok {
		return a.createErrorResponse(event, "application_name required for status query"), nil
	}

	environment, ok := event.Payload["environment"].(string)
	if !ok {
		return a.createErrorResponse(event, "environment required for status query"), nil
	}

	status, err := a.service.GetDeploymentStatus(appName, environment)
	if err != nil {
		return a.createErrorResponse(event, fmt.Sprintf("failed to get deployment status: %v", err)), nil
	}

	return &events.Event{
		Type:    events.EventTypeResponse,
		Source:  a.agentID,
		Subject: "Deployment status retrieved",
		Payload: map[string]interface{}{
			"status":            "success",
			"operation":         "get_status",
			"application_name":  appName,
			"environment":       environment,
			"deployment_status": status,
		},
	}, nil
}

// handleGenericQuestion processes general deployment-related questions
func (a *DeploymentAgent) handleGenericQuestion(ctx context.Context, event *events.Event, intent string) (*events.Event, error) {
	return &events.Event{
		Type:    events.EventTypeResponse,
		Source:  a.agentID,
		Subject: "Deployment agent response",
		Payload: map[string]interface{}{
			"status":  "processed",
			"agent":   "deployment",
			"intent":  intent,
			"message": fmt.Sprintf("Deployment agent received intent '%s'. Available operations: deploy, plan, optimize, troubleshoot, predict_impact, get_status", intent),
		},
	}, nil
}

// handleIncomingEvent is the EventBus handler that routes events to ProcessEvent
func (a *DeploymentAgent) handleIncomingEvent(event events.Event) error {
	a.logger.Info("📨 DeploymentAgent received event: %s from %s", event.Subject, event.Source)

	// Debug: Check what's in the event payload
	if correlationID, ok := event.Payload["correlation_id"]; ok {
		a.logger.Info("🔍 Event contains correlation_id: %v", correlationID)
	} else {
		a.logger.Warn("⚠️ Event missing correlation_id in payload")
	}

	// Check if this event is intended for this agent (or broadcast)
	targetAgent, hasTarget := event.Payload["target_agent"].(string)
	if hasTarget && targetAgent != a.agentID && targetAgent != "*" {
		// Event is for a different agent, ignore it
		return nil
	}

	// Process the event using the agent's main processing logic
	ctx := context.Background()
	responseEvent, err := a.ProcessEvent(ctx, &event)
	if err != nil {
		a.logger.Error("❌ Failed to process event: %v", err)
		return err
	}

	// If we got a response, emit it back
	if responseEvent != nil && a.eventBus != nil {
		a.logger.Info("📤 DeploymentAgent emitting response: %s with correlation_id: %v", responseEvent.Subject, responseEvent.Payload["correlation_id"])
		err = a.eventBus.Emit(responseEvent.Type, responseEvent.Source, responseEvent.Subject, responseEvent.Payload)
		if err != nil {
			a.logger.Error("❌ Failed to emit response event: %v", err)
		} else {
			a.logger.Info("✅ Successfully emitted response event")
		}
	} else {
		if responseEvent == nil {
			a.logger.Warn("⚠️ No response event generated from ProcessEvent")
		}
		if a.eventBus == nil {
			a.logger.Warn("⚠️ No event bus available to emit response")
		}
	}

	return nil
}

// Agent Discovery and Communication Methods

// discoverAgentsByIntent finds agents that can handle a specific intent
func (a *DeploymentAgent) discoverAgentsByIntent(ctx context.Context, intent string) ([]agents.AgentStatus, error) {
	if a.agentRegistry == nil {
		return nil, fmt.Errorf("no agent registry available for discovery")
	}

	// Get all available capabilities
	capabilities, err := a.agentRegistry.GetAvailableCapabilities(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get available capabilities: %w", err)
	}

	var matchingAgents []agents.AgentStatus

	// Find agents whose capabilities match the intent
	for _, capability := range capabilities {
		for _, supportedIntent := range capability.Intents {
			if a.intentMatches(intent, supportedIntent) {
				// Find agents with this capability
				agentsWithCapability, err := a.agentRegistry.FindAgentsByCapability(ctx, capability.Name)
				if err != nil {
					a.logger.Warn("⚠️ Failed to find agents for capability %s: %v", capability.Name, err)
					continue
				}
				matchingAgents = append(matchingAgents, agentsWithCapability...)
			}
		}
	}

	return matchingAgents, nil
}

// intentMatches checks if a user intent matches a supported capability intent
func (a *DeploymentAgent) intentMatches(userIntent, supportedIntent string) bool {
	// Direct match
	if strings.EqualFold(userIntent, supportedIntent) {
		return true
	}

	// Normalize and check for substring matches
	userNormalized := strings.ToLower(strings.ReplaceAll(userIntent, "_", " "))
	supportedNormalized := strings.ToLower(strings.ReplaceAll(supportedIntent, "_", " "))

	return strings.Contains(userNormalized, supportedNormalized) ||
		strings.Contains(supportedNormalized, userNormalized)
}

// requestAgentAction sends a request to another agent and waits for response
func (a *DeploymentAgent) requestAgentAction(ctx context.Context, intent string, payload map[string]interface{}) (*events.Event, error) {
	// Discover agents that can handle this intent
	matchingAgents, err := a.discoverAgentsByIntent(ctx, intent)
	if err != nil {
		return nil, fmt.Errorf("failed to discover agents for intent '%s': %w", intent, err)
	}

	if len(matchingAgents) == 0 {
		return nil, fmt.Errorf("no agents found for intent: %s", intent)
	}

	// Use the first available agent (could be enhanced with load balancing)
	targetAgent := matchingAgents[0]
	a.logger.Info("🎯 DeploymentAgent requesting '%s' from agent: %s", intent, targetAgent.ID)

	// Generate correlation ID for tracking
	correlationID := fmt.Sprintf("dep-req-%d", time.Now().UnixNano())
	requestID := fmt.Sprintf("req-%d", time.Now().UnixNano())

	// Prepare the event payload
	eventPayload := make(map[string]interface{})
	for k, v := range payload {
		eventPayload[k] = v
	}
	eventPayload["intent"] = intent
	eventPayload["target_agent"] = targetAgent.ID
	eventPayload["correlation_id"] = correlationID
	eventPayload["request_id"] = requestID
	eventPayload["source_agent"] = a.agentID

	// Emit the request event
	if a.eventBus != nil {
		// Find the routing key for this agent
		routingKey := a.findRoutingKeyForIntent(targetAgent, intent)
		if routingKey == "" {
			return nil, fmt.Errorf("no routing key found for intent '%s' on agent '%s'", intent, targetAgent.ID)
		}

		a.eventBus.Emit(events.EventTypeRequest, a.agentID, routingKey, eventPayload)
		a.logger.Info("📡 DeploymentAgent sent request via routing key: %s", routingKey)

		// TODO: Implement response waiting mechanism
		// For now, return success - in a full implementation, we'd wait for the response
		return &events.Event{
			Type:      events.EventTypeResponse,
			Source:    targetAgent.ID,
			Subject:   "agent_response",
			Payload:   map[string]interface{}{"status": "sent", "correlation_id": correlationID},
			Timestamp: time.Now().Unix(),
		}, nil
	}

	return nil, fmt.Errorf("no event bus available")
}

// findRoutingKeyForIntent finds the appropriate routing key for an intent on a specific agent
func (a *DeploymentAgent) findRoutingKeyForIntent(agentStatus agents.AgentStatus, intent string) string {
	// Get agent capabilities to find routing keys
	if a.agentRegistry == nil {
		return ""
	}

	ctx := context.Background()
	capabilities, err := a.agentRegistry.GetAvailableCapabilities(ctx)
	if err != nil {
		return ""
	}

	for _, capability := range capabilities {
		// Check if this capability matches the intent
		for _, supportedIntent := range capability.Intents {
			if a.intentMatches(intent, supportedIntent) {
				// Return the first routing key for this capability
				if len(capability.RoutingKeys) > 0 {
					return capability.RoutingKeys[0]
				}
			}
		}
	}

	return ""
}

// Helper methods for DeploymentAgent

// getKeys returns the keys from a map[string]interface{}
func getKeys(m map[string]interface{}) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

// getAIProviderName returns the name of the AI provider
func (a *DeploymentAgent) getAIProviderName() string {
	if a.service != nil && a.service.aiProvider != nil {
		// Try to get provider info
		if providerInfo := a.service.aiProvider.GetProviderInfo(); providerInfo != nil {
			return providerInfo.Name
		}
	}
	return "unknown"
}

// createErrorResponse creates a standardized error response event
func (a *DeploymentAgent) createErrorResponse(originalEvent *events.Event, errorMessage string) *events.Event {
	return &events.Event{
		Type:    events.EventTypeResponse,
		Source:  a.agentID,
		Subject: "Deployment operation failed",
		Payload: map[string]interface{}{
			"status":         "error",
			"error":          errorMessage,
			"context":        "deployment-agent",
			"correlation_id": originalEvent.ID, // Use original event ID for correlation
		},
		Timestamp: time.Now().Unix(),
		ID:        fmt.Sprintf("dep-agent-%d", time.Now().UnixNano()),
	}
}

// createResponse creates a standardized success response event
func (a *DeploymentAgent) createResponse(subject string, payload map[string]interface{}, originalEvent *events.Event) *events.Event {
	// Add correlation info to payload
	if payload == nil {
		payload = make(map[string]interface{})
	}
	payload["correlation_id"] = originalEvent.ID

	return &events.Event{
		Type:      events.EventTypeResponse,
		Source:    a.agentID,
		Subject:   subject,
		Payload:   payload,
		Timestamp: time.Now().Unix(),
		ID:        fmt.Sprintf("dep-agent-%d", time.Now().UnixNano()),
	}
}

// parseDeploymentRequest uses AI to extract application and environment from natural language
func (a *DeploymentAgent) parseDeploymentRequest(ctx context.Context, userMessage string) (string, string, error) {
	if a.service == nil || a.service.aiProvider == nil {
		// Fallback parsing - try to extract from simple patterns
		return a.parseDeploymentRequestFallback(userMessage)
	}

	// Use AI to parse the deployment request
	systemPrompt := `You are a deployment request parser. Extract the application name and environment from the user's message.
Return ONLY a JSON object with "application" and "environment" fields.
If environment is not specified, use "development" as default.

Examples:
Input: "deploy myapp to production"
Output: {"application": "myapp", "environment": "production"}

Input: "I want to deploy the user-service"
Output: {"application": "user-service", "environment": "development"}
`

	userPrompt := fmt.Sprintf("Parse this deployment request: %s", userMessage)

	response, err := a.service.aiProvider.CallAI(ctx, systemPrompt, userPrompt)
	if err != nil {
		a.logger.Warn("AI parsing failed, using fallback: %v", err)
		return a.parseDeploymentRequestFallback(userMessage)
	}

	// Parse the AI response
	var parsed struct {
		Application string `json:"application"`
		Environment string `json:"environment"`
	}

	if err := parseJSONResponse(response, &parsed); err != nil {
		a.logger.Warn("AI response parsing failed, using fallback: %v", err)
		return a.parseDeploymentRequestFallback(userMessage)
	}

	if parsed.Application == "" {
		return "", "", fmt.Errorf("could not extract application name from message")
	}

	if parsed.Environment == "" {
		parsed.Environment = "development"
	}

	return parsed.Application, parsed.Environment, nil
}

// parseDeploymentRequestFallback provides simple pattern-based parsing when AI is unavailable
func (a *DeploymentAgent) parseDeploymentRequestFallback(userMessage string) (string, string, error) {
	lower := strings.ToLower(userMessage)

	// Try to extract application name after "deploy"
	var appName string
	if strings.Contains(lower, "deploy ") {
		parts := strings.Split(lower, "deploy ")
		if len(parts) > 1 {
			remaining := strings.TrimSpace(parts[1])
			words := strings.Fields(remaining)
			if len(words) > 0 {
				appName = words[0]
			}
		}
	}

	// Try to extract environment
	environment := "development" // default
	if strings.Contains(lower, "production") || strings.Contains(lower, "prod") {
		environment = "production"
	} else if strings.Contains(lower, "staging") {
		environment = "staging"
	} else if strings.Contains(lower, "test") {
		environment = "test"
	}

	if appName == "" {
		return "", "", fmt.Errorf("could not extract application name from message: %s", userMessage)
	}

	return appName, environment, nil
}

// buildDeploymentPlan creates a comprehensive deployment plan and coordinates with ReleaseAgent
func (a *DeploymentAgent) buildDeploymentPlan(ctx context.Context, appName, environment string) (map[string]interface{}, error) {
	a.logger.Info("🏗️ Building deployment plan for %s in %s", appName, environment)

	// Step 1: Create a Release via ReleaseAgent (agent-to-agent communication)
	releaseID, err := a.createReleaseViaAgent(ctx, appName, environment)
	if err != nil {
		a.logger.Error("Failed to create release via ReleaseAgent: %v", err)
		return nil, fmt.Errorf("failed to create release: %w", err)
	}

	a.logger.Info("✅ Created release %s via ReleaseAgent", releaseID)

	// Step 2: Generate deployment plan using AI
	deploymentPlan, err := a.service.GenerateDeploymentPlan(ctx, appName)
	if err != nil {
		a.logger.Error("Failed to generate deployment plan: %v", err)
		return nil, fmt.Errorf("failed to generate deployment plan: %w", err)
	}

	// Step 3: Create comprehensive plan response
	plan := map[string]interface{}{
		"application":      appName,
		"environment":      environment,
		"release_id":       releaseID,
		"deployment_steps": deploymentPlan,
		"created_at":       time.Now().UTC(),
		"agent":            a.agentID,
		"status":           "planned",
	}

	return plan, nil
}

// createReleaseViaAgent communicates with ReleaseAgent to create a release
func (a *DeploymentAgent) createReleaseViaAgent(ctx context.Context, appName, environment string) (string, error) {
	a.logger.Info("📞 Requesting ReleaseAgent to create release for %s", appName)

	// Discover ReleaseAgent by intent
	intent := "create release"
	agents, err := a.discoverAgentsByIntent(ctx, intent)
	if err != nil {
		return "", fmt.Errorf("failed to discover release agent: %w", err)
	}

	if len(agents) == 0 {
		return "", fmt.Errorf("no release agent available to handle intent: %s", intent)
	}

	// Use the first available ReleaseAgent
	releaseAgent := agents[0]
	a.logger.Info("🎯 Found ReleaseAgent: %s", releaseAgent.ID)

	// Create request payload
	payload := map[string]interface{}{
		"application":  appName,
		"environment":  environment,
		"requested_by": a.agentID,
		"user_message": fmt.Sprintf("create release for %s in %s", appName, environment),
	}

	// Send request to ReleaseAgent
	response, err := a.requestAgentAction(ctx, intent, payload)
	if err != nil {
		return "", fmt.Errorf("failed to request release creation: %w", err)
	}

	// Extract release ID from response
	if response.Payload == nil {
		return "", fmt.Errorf("empty response from release agent")
	}

	releaseID, ok := response.Payload["release_id"].(string)
	if !ok {
		return "", fmt.Errorf("release agent did not return release_id")
	}

	return releaseID, nil
}

// generateDeploymentPlanExplanation creates a human-readable explanation of the deployment plan
func (a *DeploymentAgent) generateDeploymentPlanExplanation(ctx context.Context, plan map[string]interface{}) (string, error) {
	if a.service == nil || a.service.aiProvider == nil {
		return a.generateBasicExplanation(plan), nil
	}

	// Use AI to generate a comprehensive explanation
	systemPrompt := `You are a deployment expert. Create a clear, human-readable explanation of the deployment plan.
Focus on what will happen, in what order, and any important considerations.
Keep it concise but informative.`

	planJSON, _ := json.Marshal(plan)
	userPrompt := fmt.Sprintf("Explain this deployment plan: %s", string(planJSON))

	response, err := a.service.aiProvider.CallAI(ctx, systemPrompt, userPrompt)
	if err != nil {
		a.logger.Warn("AI explanation generation failed, using basic explanation: %v", err)
		return a.generateBasicExplanation(plan), nil
	}

	return response, nil
}

// generateBasicExplanation creates a simple explanation when AI is not available
func (a *DeploymentAgent) generateBasicExplanation(plan map[string]interface{}) string {
	appName, _ := plan["application"].(string)
	environment, _ := plan["environment"].(string)
	releaseID, _ := plan["release_id"].(string)

	explanation := fmt.Sprintf("Deployment plan for %s to %s environment", appName, environment)
	if releaseID != "" {
		explanation += fmt.Sprintf(" (Release: %s)", releaseID)
	}

	if steps, ok := plan["deployment_steps"].([]interface{}); ok {
		explanation += fmt.Sprintf("\nPlanned steps: %d deployment actions", len(steps))
	}

	return explanation
}

// convertToDeploymentSteps converts generic data to deployment steps
func (a *DeploymentAgent) convertToDeploymentSteps(data interface{}, steps *[]ai.DeploymentStep) error {
	// Convert the data to deployment steps based on its type
	switch v := data.(type) {
	case []interface{}:
		for i, step := range v {
			if stepMap, ok := step.(map[string]interface{}); ok {
				deployStep := ai.DeploymentStep{
					ID:          fmt.Sprintf("step-%d", i+1),
					Type:        "deployment",
					Description: fmt.Sprintf("%v", stepMap),
				}
				if desc, ok := stepMap["description"].(string); ok {
					deployStep.Description = desc
				}
				if cmd, ok := stepMap["command"].(string); ok {
					deployStep.Command = cmd
				}
				*steps = append(*steps, deployStep)
			}
		}
	case map[string]interface{}:
		// Single step
		deployStep := ai.DeploymentStep{
			ID:          "step-1",
			Type:        "deployment",
			Description: fmt.Sprintf("%v", v),
		}
		if desc, ok := v["description"].(string); ok {
			deployStep.Description = desc
		}
		if cmd, ok := v["command"].(string); ok {
			deployStep.Command = cmd
		}
		*steps = append(*steps, deployStep)
	default:
		return fmt.Errorf("unsupported deployment steps format: %T", data)
	}
	return nil
}

// convertToProposedChanges converts generic data to proposed changes
func (a *DeploymentAgent) convertToProposedChanges(data interface{}, changes *[]ai.ProposedChange) error {
	switch v := data.(type) {
	case []interface{}:
		for _, change := range v {
			if changeMap, ok := change.(map[string]interface{}); ok {
				proposedChange := ai.ProposedChange{
					Type:        "update", // default
					Target:      "deployment",
					Description: fmt.Sprintf("%v", changeMap),
				}
				if changeType, ok := changeMap["type"].(string); ok {
					proposedChange.Type = changeType
				}
				if target, ok := changeMap["target"].(string); ok {
					proposedChange.Target = target
				}
				if desc, ok := changeMap["description"].(string); ok {
					proposedChange.Description = desc
				}
				*changes = append(*changes, proposedChange)
			}
		}
	case map[string]interface{}:
		// Single change
		proposedChange := ai.ProposedChange{
			Type:        "update",
			Target:      "deployment",
			Description: fmt.Sprintf("%v", v),
		}
		if changeType, ok := v["type"].(string); ok {
			proposedChange.Type = changeType
		}
		if target, ok := v["target"].(string); ok {
			proposedChange.Target = target
		}
		if desc, ok := v["description"].(string); ok {
			proposedChange.Description = desc
		}
		*changes = append(*changes, proposedChange)
	default:
		return fmt.Errorf("unsupported proposed changes format: %T", data)
	}
	return nil
}

// parseJSONResponse parses a JSON response string into the given target
func parseJSONResponse(response string, target interface{}) error {
	// Clean up the response - remove any markdown code blocks
	cleaned := strings.TrimSpace(response)
	if strings.HasPrefix(cleaned, "```json") {
		cleaned = strings.TrimPrefix(cleaned, "```json")
	}
	if strings.HasPrefix(cleaned, "```") {
		cleaned = strings.TrimPrefix(cleaned, "```")
	}
	if strings.HasSuffix(cleaned, "```") {
		cleaned = strings.TrimSuffix(cleaned, "```")
	}
	cleaned = strings.TrimSpace(cleaned)

	return json.Unmarshal([]byte(cleaned), target)
}
